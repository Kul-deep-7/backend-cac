Authentication: Who are you?
Authorization: What are you allowed to access?


“User registers with credentials, data is validated, password is hashed and stored.
On login, user is verified and access and refresh tokens are generated.
Access token is short-lived and used to access protected routes.
Refresh token is stored in the database and used to generate new access tokens.
On refresh, the incoming refresh token is compared with the one in the database to prevent reuse.
On logout, refresh token is removed from DB and cookies are cleared, fully invalidating the session.”


TOKEN ROTATION-

In generateAccessAndRefreshTokens, we generate tokens by calling the methods we created inside the User model. 
Those methods internally use jwt.sign() to create the access token and refresh token. When we call 
generateAccessAndRefreshTokens(user._id), we pass the user’s ID, so the function fetches the same existing user 
from the database. That user object then generates new tokens, and the newly generated refresh token is stored 
back in the database, replacing the old refresh token that was used. This way, the old refresh token becomes 
invalid and the user now has a new refresh token saved in the DB.

Refresh token rotation means that every time a refresh token is used, the server invalidates the old refresh token 
and issues a new one. This prevents stolen refresh tokens from being reused, because only the most recently issued 
refresh token remains valid

To be crystal clear:

You use the old refresh token once to identify the user
You generate a new refresh token using jwt.sign() via model methods
You overwrite the old refresh token in the database
The old refresh token immediately becomes invalid

1. User logs in initially:
   ┌─────────────────────────────────────────────┐
   │ generateAccessAndRefreshTokens(user._id)    │
   │ ↓                                           │
   │ User.findById(user._id)                     │
   │ ↓                                           │
   │ user.generateAccessToken()  → jwt.sign()    │
   │ user.generateRefreshToken() → jwt.sign()    │
   │ ↓                                           │
   │ user.refreshToken = newRefreshToken         │
   │ user.save()                                 │
   └─────────────────────────────────────────────┘
   Returns: {accessToken, refreshToken}

2. Access token expires (15 min later):
   ┌─────────────────────────────────────────────┐
   │ Client sends refresh request with old token │
   │ ↓                                           │
   │ generateAccessAndRefreshTokens(user._id)    │
   │ ↓                                           │
   │ User.findById(user._id)                     │
   │ ↓                                           │
   │ Check: Does DB refreshToken == sent token?  │
   │ If YES → Continue                           │
   │ If NO  → Reject (token reuse/theft)         │
   │ ↓                                           │
   │ Generate NEW tokens                         │
   │ user.refreshToken = NEW refresh token       │
   │ user.save() ← REPLACES old with new         │
   └─────────────────────────────────────────────┘
   Returns: {NEW accessToken, NEW refreshToken}



Why refresh token works only once in Postman

In my backend, I use refresh token rotation.
This means every time the refresh token endpoint is called:
A new access token is generated
A new refresh token is generated
The old refresh token is replaced in the database

What happens step by step

User logs in
→ Backend generates Access Token + Refresh Token
→ Refresh token is stored in DB and also sent as httpOnly cookie

Postman calls /refresh-token first time
Backend verifies refresh token
Matches it with DB
Generates new access token + new refresh token
Old refresh token becomes invalid
DB now stores the new refresh token
Postman calls /refresh-token second time
Postman still sends the old refresh token
Backend compares: Incoming refresh token 
                  Stored refresh token in DB (new one)
Tokens do not match
Backend throws “Invalid refresh token”

Why this happens in Postman:
Postman does not automatically update cookies correctly after rotation
So it keeps sending the old refresh token
That token is already invalidated by rotation
Hence, refresh works only once

How this works in real frontend apps:
Browser automatically updates cookies
Frontend calls refresh endpoint silently
User never notices token refresh
Refresh token rotation works smoothly


Access tokens are short-lived and used for authorization. Refresh tokens are long-lived, stored securely in the database, 
and used only to issue new access tokens. On logout, the refresh token is removed from the database, fully invalidating the session


Logout requires a database update because JWT access tokens are stateless and cannot be revoked. By deleting the 
refresh token from the database, we ensure that no new access tokens can be generated, effectively terminating the user’s session.


JWT is a token format used to securely transmit claims between client and server. It is stateless and does not store session data on 
the server. The server verifies the token signature to trust the claims, unlike traditional server-side sessions.
JWT is Base64 encoded, not encrypted
Anyone can decode header & payload
Security comes from the signature
JWT represents claims, not a session

JWT header and payload are Base64 encoded, not encrypted, so anyone can decode them. Security comes from the signature, which prevents tampering without the secret key

The verifyJWT middleware runs before the controller and verifies the access token. After verification, it decodes the token and attaches the logged-in user’s data to req.user. Because of this, before the controller starts executing, the backend already knows which user is logged in. Using req.user._id, the controller can safely update that specific user’s data in the database without relying on the client to send a user ID.